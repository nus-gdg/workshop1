using UnityEngine;

namespace Combat
{
    /// <summary>
    /// Handles the high-level calculation of elemental damage and weaknesses
    /// </summary>
    public class ElementalDamageCalculator : MonoBehaviour
    {
        /* Workflow:
         * 1) Player has a ResistanceHandler MonoBehaviour script with 
         * assignable Element (ScriptableObject), DamageTransform 
         * (template as ScriptableObject), hyperparameters (int[] that 
         * initialises DamageTransform).
         * 2) If a player wants to increase resistance against an attack, 
         * he must call ResistanceHandler.AddResistance to update the 
         * resistance values
         * 3) The CalculateDamage function will then calculate damage 
         * based on Element, raw damage and ResistanceHandler stats. 
         * I've decided against using a ScriptableObject to encapsulate
         * one attack because the damage can become too variable. 
         * 
         * To do: currently ElementalDamageCalculator and ResistanceHandler
         * are coupled. Decouple them
        */

        #region Public Structs
        /// <summary>
        /// A struct that contains Element element, DamageTransform damageTransform 
        /// and int[] hyperparameters. <see cref="ResistanceHandler"/> will initialise 
        /// the <see cref="DamageTransform"/> class with the hyperparameters passed in. 
        /// </summary>
        [System.Serializable]
        public struct ResistanceMapping
        {
            public Element element;
            public DamageTransform damageTransform;
            public float[] hyperparameters;
        }

        /// <summary>
        /// A struct that contains Element element and DamageTransform 
        /// damageTransform. This is generated by <see cref="ResistanceHandler"/> 
        /// from <see cref="ResistanceMapping"/> and you should not 
        /// attempt to modify these values directly. 
        /// </summary>
        public struct ElementModifier
        {
            public Element element;
            public DamageTransform damageTransform;
        }
        #endregion

        /// <summary>
        /// Calculates final damage given incoming damage and element. If 
        /// the resistance against a given element is not defined, the 
        /// incoming damage will be the same as the outgoing damage by default. 
        /// </summary>
        /// <param name="element">Element of incoming damage</param>
        /// <param name="damage">Raw damage value before resistances</param>
        /// <param name="resistances">A stats container</param>
        /// <returns></returns>
        public static int CalculateDamage(Element element,
            int damage, ResistanceHandler resistances)
        {
            DamageTransform modifier = resistances.GetResistanceFunction(element);
            if (modifier != null)
            {
                return modifier.DamageFunction(damage);
            }
            else
            {
                return damage;
            }
        }
    }
}
